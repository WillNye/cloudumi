# generated by datamodel-codegen:
#   filename:  swagger.yaml
#   timestamp: 2023-01-02T21:45:27+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import EmailStr, Field, conint, constr

from common.lib.pydantic import BaseModel


class ActionResult(BaseModel):
    status: Optional[str] = None
    message: Optional[str] = None


class Action(Enum):
    attach = "attach"
    detach = "detach"


class ResourceModel(BaseModel):
    arn: str = Field(..., description="resource ARN")
    name: str = Field(..., description="Resource Name")
    account_id: Optional[str] = Field(None, description="AWS account ID")
    region: Optional[str] = Field(None, description="Region")
    account_name: Optional[str] = Field(
        None, description="human-friendly AWS account name"
    )
    policy_sha256: Optional[str] = Field(
        None, description="hash of the most recent resource policy seen by NOQ"
    )
    policy: Optional[str] = None
    actions: Optional[List[str]] = None
    owner: Optional[str] = Field(
        None, description="email address of team or individual who owns this resource"
    )
    approvers: Optional[List[str]] = None
    resource_type: str
    last_updated: Optional[datetime] = Field(
        None, description="last time resource was updated from source-of-truth"
    )


class RequestStatus(Enum):
    pending = "pending"
    cancelled = "cancelled"
    approved = "approved"
    rejected = "rejected"
    expired = "expired"


class GeneratorType(Enum):
    advanced = "advanced"
    crud_lookup = "crud_lookup"
    ec2 = "ec2"
    generic = "generic"
    rds = "rds"
    route53 = "route53"
    s3 = "s3"
    ses = "ses"
    sns = "sns"
    sqs = "sqs"
    sts = "sts"
    custom_iam = "custom_iam"


class PrincipalType(Enum):
    AwsResource = "AwsResource"
    HoneybeeAwsResourceTemplate = "HoneybeeAwsResourceTemplate"
    TerraformAwsResource = "TerraformAwsResource"


class PrincipalModel(BaseModel):
    principal_type: PrincipalType


class ResourceType(Enum):
    role = "role"


class AwsResourcePrincipalModel(PrincipalModel):
    principal_type: constr(regex=r"AwsResource")
    principal_arn: Optional[
        constr(
            regex=r"(^arn:([^:]*):([^:]*):([^:]*):(|\*|[\d]{12}|cloudfront|aws):(.+)$)|^\*$"
        )
    ] = Field(
        None,
        description="The principal (Source ARN) associated with the Change. This is most commomly an IAM role ARN.\nThe principal ARN is associated with the entity whose policy will be modified if the change is\napproved and successful.",
        example="arn:aws:iam::123456789012:role/exampleRole",
    )
    account_id: Optional[constr(min_length=12, max_length=12)] = Field(
        None, example="123456789012"
    )
    name: Optional[str] = None
    resource_type: Optional[ResourceType] = None


class TerraformAwsResourcePrincipalModel(PrincipalModel):
    principal_type: constr(regex=r"TerraformAwsResource")
    repository_name: str = Field(
        ...,
        description="The name of the repository for the template. This is specified in the configuration key\n`cache_resource_templates.repositories[n].name`",
    )
    resource_identifier: str = Field(..., example="path/to/template.tf")
    resource_url: str = Field(..., example="https://example.com/resource.tf")
    file_path: Optional[str] = Field(None, example="path/to/template.tf")


class HoneybeeAwsResourceTemplatePrincipalModel(PrincipalModel):
    principal_type: constr(regex=r"HoneybeeAwsResourceTemplate")
    repository_name: str = Field(
        ...,
        description="The name of the repository for the template. This is specified in the configuration key\n`cache_resource_templates.repositories[n].name`",
    )
    resource_identifier: str = Field(..., example="path/to/template.yaml")
    resource_url: str = Field(..., example="https://example.com/resource")


class Status(Enum):
    applied = "applied"
    not_applied = "not_applied"
    cancelled = "cancelled"
    expired = "expired"


class ChangeModel(BaseModel):
    principal: Union[
        AwsResourcePrincipalModel,
        HoneybeeAwsResourceTemplatePrincipalModel,
        TerraformAwsResourcePrincipalModel,
    ]
    change_type: str
    resources: Optional[List[ResourceModel]] = []
    version: Optional[str] = 3.0
    status: Optional[Status] = "not_applied"
    id: Optional[str] = None
    autogenerated: Optional[bool] = False
    updated_by: Optional[str] = None
    cli_command: Optional[str] = None
    python_script: Optional[str] = None
    read_only: Optional[bool] = False
    auto_merge: Optional[bool] = Field(
        False, description="if set, automatically merges a policy that is not `new`"
    )


class Encoding(Enum):
    yaml = "yaml"
    json = "json"
    hcl = "hcl"
    text = "text"


class GenericFileChangeModel(ChangeModel):
    principal: Optional[
        Union[
            AwsResourcePrincipalModel,
            HoneybeeAwsResourceTemplatePrincipalModel,
            TerraformAwsResourcePrincipalModel,
        ]
    ] = None
    action: Optional[Action] = None
    change_type: Optional[constr(regex=r"generic_file")] = None
    policy: Optional[str] = None
    old_policy: Optional[str] = None
    encoding: Optional[Encoding] = None


class TagAction(Enum):
    create = "create"
    update = "update"
    delete = "delete"


class ResourceTagChangeModel(ChangeModel):
    original_key: Optional[str] = Field(
        None,
        description="original_key is used for renaming a key to something else. This is optional.",
        example="key_to_be_renamed",
    )
    key: Optional[str] = Field(
        None,
        description="This is the desired key name for the tag. If a tag key is being renamed, this is what it will be renamed\nto. Otherwise, this key name will be used when creating or updating a tag.",
        example="desired_key_name",
    )
    original_value: Optional[str] = None
    value: Optional[str] = None
    change_type: Optional[constr(regex=r"resource_tag")] = None
    tag_action: TagAction


class TraRoleChangeModel(ChangeModel):
    change_type: Optional[constr(regex=r"tra_can_assume_role")] = None


class CreateResourceChangeModel(ChangeModel):
    change_type: Optional[constr(regex=r"create_resource")] = None
    instance_profile: Optional[bool] = True
    description: str


class DeleteResourceChangeModel(ChangeModel):
    change_type: Optional[constr(regex=r"delete_resource")] = None


class Action1(Enum):
    add = "add"
    remove = "remove"


class RoleAccessChangeModel(ChangeModel):
    change_type: Optional[constr(regex=r"assume_role_access")] = None
    identities: List[str] = Field(
        ..., description="The users and groups this change will apply to"
    )
    action: Action1 = Field(
        ...,
        description="Will role access be added or removed from the provided identities",
    )


class TenantDetailsModel(BaseModel):
    name: str = Field(..., description="Tenant Name")
    membership_tier: float = Field(
        ..., description="The type of membership the tenant has"
    )
    created_by: str = Field(..., description="The user who created the Noq account")
    created_at: float
    eula_info: Dict[str, Any] = Field(
        ...,
        description="Details about the tenant's EULA agreement like who signed it, when, and what version",
    )
    license_expiration: Optional[float] = Field(
        None,
        description="When the tenants account will be set to inactive if not renewed",
    )


class ManagedPolicyChangeModel(ChangeModel):
    arn: constr(
        regex=r"(^arn:([^:]*):([^:]*):([^:]*):(|\*|[\d]{12}|cloudfront|aws):(.+)$)|^\*$"
    )
    change_type: Optional[constr(regex=r"managed_policy")] = None
    action: Action


class PermissionsBoundaryChangeModel(ChangeModel):
    arn: constr(
        regex=r"(^arn:([^:]*):([^:]*):([^:]*):(|\*|[\d]{12}|cloudfront|aws):(.+)$)|^\*$"
    )
    change_type: Optional[constr(regex=r"permissions_boundary")] = None
    action: Action


class ArnArray(BaseModel):
    __root__: List[
        constr(
            regex=r"^arn:([^:]*):([^:]*):([^:]*):(|\*|[\d]{12}|cloudfront|aws):(.+)$"
        )
    ]


class Status1(Enum):
    active = "active"
    in_progress = "in-progress"
    in_active = "in-active"
    deleted = "deleted"
    created = "created"
    suspended = "suspended"
    deprecated = "deprecated"


class Type(Enum):
    aws = "aws"
    gcp = "gcp"


class Environment(Enum):
    prod = "prod"
    test = "test"


class CloudAccountModel(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    status: Optional[Status1] = None
    type: Optional[Type] = None
    sync_enabled: Optional[bool] = None
    sensitive: Optional[bool] = False
    environment: Optional[Environment] = None
    aliases: Optional[List[str]] = None
    email: Optional[str] = None


class PolicyModel(BaseModel):
    version: Optional[str] = Field(None, description="AWS Policy Version")
    policy_document: Optional[Dict[str, Any]] = Field(
        None, description="JSON policy document"
    )
    policy_sha256: Optional[str] = Field(
        None, description="hash of the policy_document json"
    )


class PolicyStatement(BaseModel):
    action: List[str] = Field(..., description="AWS Policy Actions")
    effect: str = Field(..., description="Allow | Deny")
    resource: List[str] = Field(..., description="AWS Resource ARNs")
    sid: Optional[constr(regex=r"^([a-zA-Z0-9]+)*")] = Field(
        None, description="Statement identifier"
    )


class PolicyDocumentModel(BaseModel):
    Version: Optional[str] = None
    Statement: Optional[List[PolicyStatement]] = None


class PolicyVersionModel(BaseModel):
    IsDefaultVersion: Optional[bool] = None
    CreateDate: Optional[datetime] = None
    document: Optional[PolicyDocumentModel] = None


class Configuration(BaseModel):
    policyName: Optional[str] = None
    arn: Optional[str] = None
    path: Optional[str] = None
    createDate: Optional[datetime] = None
    updateDate: Optional[datetime] = None
    policyVersionList: Optional[List[PolicyVersionModel]] = None


class ConfigurationChangeModel(BaseModel):
    version: Optional[str] = None
    configurationItemStatus: Optional[str] = None
    configurationItemCaptureTime: Optional[datetime] = None
    arn: Optional[str] = None
    resourceType: Optional[str] = None
    resourceName: Optional[str] = None
    awsRegion: Optional[str] = None
    availabilityZone: Optional[str] = None
    resourceCreationTime: Optional[datetime] = None
    tags: Optional[Dict[str, Any]] = None
    relatedEvents: Optional[List] = None
    relationships: Optional[List] = None
    configuration: Optional[Configuration] = None


class ConfigurationEventModel(BaseModel):
    config_change: Optional[ConfigurationChangeModel] = None
    updated_at: Optional[datetime] = None
    rollback_supported: Optional[bool] = None
    resource_url: Optional[str] = None


class SetupMfaRequestModel(BaseModel):
    user_code: Optional[str] = None
    access_token: Optional[str] = None


class AwsPrincipalModel(BaseModel):
    name: str = Field(..., example="super_awesome_admin")
    account_id: constr(min_length=12, max_length=12) = Field(
        ..., example="123456789012"
    )
    account_name: Optional[str] = Field(None, example="super_awesome")
    arn: Optional[
        constr(
            regex=r"(^arn:([^:]*):([^:]*):([^:]*):(|\*|[\d]{12}|cloudfront|aws):(.+)$)|^\*$"
        )
    ] = Field(None, example="arn:aws:iam::123456789012:role/super_awesome_admin")


class CloudTrailError(BaseModel):
    event_call: Optional[str] = Field(None, example="sqs:CreateQueue")
    resource: Optional[str] = Field(
        None, example="arn:aws:iam::123456789012:role/roleName"
    )
    generated_policy: Optional[Dict[str, Any]] = Field(
        None,
        example={
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Resource": ["arn:aws:iam::123456789012:role/roleName"],
                    "Action": ["sts:AssumeRole"],
                    "Effect": "Allow",
                }
            ],
        },
    )
    count: Optional[int] = Field(None, example=5)


class CloudTrailErrorArray(BaseModel):
    cloudtrail_errors: Optional[List[CloudTrailError]] = None


class CloudTrailDetailsModel(BaseModel):
    error_url: Optional[str] = Field(
        None, example="https://cloudtrail_logs/for/role_arn"
    )
    errors: Optional[CloudTrailErrorArray] = None


class S3Error(BaseModel):
    error_call: Optional[str] = Field(None, example="s3:PutObject")
    count: Optional[int] = Field(None, example=5)
    bucket_name: Optional[str] = Field(None, example="bucket_name")
    request_prefix: Optional[str] = Field(None, example="folder/file.txt")
    status_code: Optional[int] = Field(None, example=403)
    status_text: Optional[str] = Field(None, example="AccessDenied")
    role_arn: Optional[
        constr(
            regex=r"(^arn:([^:]*):([^:]*):([^:]*):(|\*|[\d]{12}|cloudfront|aws):(.+)$)|^\*$"
        )
    ] = Field(None, example="arn:aws:iam::123456789012:role/roleName")


class S3ErrorArray(BaseModel):
    s3_errors: Optional[List[S3Error]] = None


class S3DetailsModel(BaseModel):
    query_url: Optional[str] = Field(
        None, example="https://s3_log_query/for/role_or_bucket_arn"
    )
    error_url: Optional[str] = Field(
        None, example="https://s3_error_query/for/role_or_bucket_arn"
    )
    errors: Optional[S3ErrorArray] = None


class AppDetailsModel(BaseModel):
    name: Optional[str] = Field(None, example="app_name")
    owner: Optional[str] = Field(None, example="owner@example.com")
    owner_url: Optional[str] = Field(None, example="https://link_to_owner_group")
    app_url: Optional[str] = Field(
        None, example="https://link_to_app_ci_pipeline_for_app"
    )


class AppDetailsArray(BaseModel):
    app_details: Optional[List[AppDetailsModel]] = None


class PrincipalModelTraConfig(BaseModel):
    active_users: Optional[List[str]] = None
    supported_groups: Optional[List[str]] = None
    can_edit: Optional[bool] = False


class PrincipalModelRoleAccessConfig(BaseModel):
    noq_authorized_cli_tag: Optional[str] = None
    noq_authorized_tag: Optional[str] = None
    is_valid_config: Optional[bool] = False
    noq_authorized_groups: Optional[List[Dict[str, Any]]] = None
    noq_authorized_cli_groups: Optional[List[Dict[str, Any]]] = None
    can_edit: Optional[bool] = False


class ExtendedAwsPrincipalModel(AwsPrincipalModel):
    inline_policies: List[Dict[str, Any]]
    assume_role_policy_document: Optional[Dict[str, Any]] = None
    cloudtrail_details: Optional[CloudTrailDetailsModel] = None
    s3_details: Optional[S3DetailsModel] = None
    apps: Optional[AppDetailsArray] = None
    managed_policies: List[Dict[str, Any]]
    permissions_boundary: Optional[Dict[str, Any]] = None
    tags: List[Dict[str, Any]]
    elevated_access_config: Optional[PrincipalModelTraConfig] = None
    role_access_config: Optional[PrincipalModelRoleAccessConfig] = None
    effective_policy: Optional[Dict[str, Any]] = Field(
        None,
        description='"The minified effective policy for the principal. This is effectively a combination "\n"of the inline policies and managed policies of the principal. "',
    )
    effective_policy_repoed: Optional[Dict[str, Any]] = Field(
        None,
        description='"The minified effective policy for the principal, with unused permissions removed."',
    )
    config_timeline_url: Optional[str] = Field(
        None, description="A link to the role's AWS Config Timeline"
    )
    templated: Optional[bool] = None
    template_link: Optional[str] = None
    created_time: Optional[str] = None
    updated_time: Optional[str] = None
    last_used_time: Optional[str] = None
    description: Optional[str] = None
    owner: Optional[str] = Field(
        None,
        description="A string depicting the owning user or group for a given AWS principal. Typically determined by one or\nmore tags on the principal.",
    )
    terraform: Optional[str] = Field(
        None,
        description="A string depicting the terraformed version of the principal, if available.",
    )
    read_only: Optional[bool] = None


class UserModel(BaseModel):
    email: Optional[str] = None
    extended_info: Optional[Dict[str, Any]] = None
    details_url: Optional[str] = Field(None, example="https://details_about/user")
    photo_url: Optional[str] = Field(
        None, example="https://user_photos/user_thumbnail.jpg"
    )


class ApiErrorModel(BaseModel):
    status: Optional[int] = None
    title: Optional[str] = None
    message: Optional[str] = None


class AWSCredentials(BaseModel):
    aws_access_key_id: str
    aws_secret_access_key: str
    aws_session_token: Optional[str] = None


class CloudCredentials(BaseModel):
    aws: Optional[AWSCredentials] = Field(None, is_secret=True)


class Options(BaseModel):
    assume_role_policy: Optional[bool] = False
    tags: Optional[bool] = False
    copy_description: Optional[bool] = False
    description: Optional[str] = None
    inline_policies: Optional[bool] = False
    managed_policies: Optional[bool] = False
    max_session_duration: Optional[bool] = False


class CloneRoleRequestModel(BaseModel):
    account_id: constr(min_length=12, max_length=12)
    role_name: str
    dest_account_id: constr(min_length=12, max_length=12)
    dest_role_name: str
    options: Options


class CreateCloneRequestResponse(BaseModel):
    errors: Optional[int] = None
    role_created: Optional[bool] = None
    action_results: Optional[List[ActionResult]] = None


class RoleCreationRequestModel(BaseModel):
    account_id: constr(min_length=12, max_length=12)
    role_name: str
    description: Optional[str] = None
    instance_profile: Optional[bool] = True


class Command(Enum):
    add_comment = "add_comment"
    approve_request = "approve_request"
    reject_request = "reject_request"
    cancel_request = "cancel_request"
    apply_change = "apply_change"
    update_change = "update_change"
    cancel_change = "cancel_change"
    move_back_to_pending = "move_back_to_pending"
    update_expiration_date = "update_expiration_date"
    update_ttl = "update_ttl"


class RequestModificationBaseModel(BaseModel):
    credentials: Optional[CloudCredentials] = Field(None, is_secret=True)
    command: Command


class ExpirationDateRequestModificationModel(RequestModificationBaseModel):
    expiration_date: Optional[str] = Field(
        ..., description="Date to expire requested policy"
    )


class TTLRequestModificationModel(RequestModificationBaseModel):
    ttl: Optional[conint(ge=1)] = Field(
        ...,
        description="The time, in seconds, before the request expires after it has been approved.",
        example=43200,
    )


class CommentRequestModificationModel(RequestModificationBaseModel):
    comment_text: str


class UpdateChangeModificationModel(RequestModificationBaseModel):
    policy_document: Dict[str, Any]
    change_id: str


class ApplyChangeModificationModel(RequestModificationBaseModel):
    policy_document: Optional[Dict[str, Any]] = None
    change_id: Optional[str] = None
    apply_all_changes: Optional[bool] = False
    apps: Optional[AppDetailsArray] = None


class CancelChangeModificationModel(RequestModificationBaseModel):
    policy_document: Optional[Dict[str, Any]] = None
    change_id: str


class ChangeRequestStatusModificationModel(RequestModificationBaseModel):
    pass


class MoveToPendingRequestModificationModel(RequestModificationBaseModel):
    pass


class PolicyRequestChange(BaseModel):
    policy_document: Dict[str, Any]
    change_id: str


class ApproveRequestModificationModel(RequestModificationBaseModel):
    policy_request_changes: Optional[List[PolicyRequestChange]] = None


class PolicyRequestModificationRequestModel(BaseModel):
    modification_model: Union[
        CommentRequestModificationModel,
        UpdateChangeModificationModel,
        ExpirationDateRequestModificationModel,
        TTLRequestModificationModel,
        ApplyChangeModificationModel,
        ApproveRequestModificationModel,
        MoveToPendingRequestModificationModel,
        ChangeRequestStatusModificationModel,
    ]


class ActionResult1(BaseModel):
    status: Optional[str] = None
    message: Optional[str] = None
    visible: Optional[bool] = True


class PolicyRequestModificationResponseModel(BaseModel):
    errors: Optional[int] = None
    action_results: Optional[List[ActionResult1]] = None


class AuthenticationResponse(BaseModel):
    authenticated: Optional[bool] = None
    errors: Optional[List[str]] = None
    username: Optional[str] = None
    groups: Optional[List[str]] = None


class UserManagementAction(Enum):
    create = "create"
    update = "update"
    delete = "delete"


class UserManagementModel(BaseModel):
    user_management_action: Optional[UserManagementAction] = None
    username: Optional[str] = None
    password: Optional[str] = None
    groups: Optional[List[str]] = None


class LoginAttemptModel(BaseModel):
    username: Optional[str] = None
    password: Optional[str] = None
    after_redirect_uri: Optional[str] = None


class RegistrationAttemptModel(BaseModel):
    username: str
    password: str


class Status2(Enum):
    success = "success"
    error = "error"
    redirect = "redirect"


class WebResponse(BaseModel):
    status: Optional[Status2] = None
    reason: Optional[str] = Field(
        None,
        example=["authenticated_redirect", "authentication_failure", "not_configured"],
    )
    redirect_url: Optional[str] = None
    status_code: Optional[int] = None
    message: Optional[str] = None
    errors: Optional[List[str]] = None
    count: Optional[int] = None
    total: Optional[int] = None
    page: Optional[int] = None
    last_page: Optional[int] = None
    data: Optional[Union[Dict[str, Any], List]] = None


class DataTableResponse(BaseModel):
    totalCount: int
    filteredCount: int
    data: List[Dict[str, Any]]


class PolicyCheckModelItem(BaseModel):
    issue: Optional[str] = None
    detail: Optional[str] = None
    location: Optional[str] = None
    severity: Optional[str] = None
    title: Optional[str] = None
    description: Optional[str] = None


class PolicyCheckModel(BaseModel):
    __root__: List[PolicyCheckModelItem]


class ServiceControlPolicyDetailsModel(BaseModel):
    id: str
    arn: str
    name: str
    description: str
    type: Optional[str] = None
    aws_managed: bool
    content: str


class ServiceControlPolicyTargetModel(BaseModel):
    target_id: str
    arn: str
    name: str
    type: str


class ServiceControlPolicyModel(BaseModel):
    targets: List[ServiceControlPolicyTargetModel]
    policy: ServiceControlPolicyDetailsModel


class ServiceControlPolicyArrayModel(BaseModel):
    __root__: List[ServiceControlPolicyModel]


class EligibleRolesModel(BaseModel):
    arn: str = Field(..., description="ARN of the role")
    account_id: str = Field(..., description="Account ID of the role")
    account_friendly_name: Optional[str] = Field(
        None, description='Account\'s friendly name (if known), otherwise "Unknown"'
    )
    role_name: str = Field(..., description="Name of the role")
    apps: Optional[AppDetailsArray] = None


class EligibleRolesModelArray(BaseModel):
    roles: Optional[List[EligibleRolesModel]] = None


class EulaModel(BaseModel):
    eula: Optional[str] = Field(None, description="The text of the EULA.")


class HubAccount(BaseModel):
    name: str = Field(
        ..., description="Customer-specified or default hub role name (NoqCentralRole)"
    )
    account_name: Optional[str] = Field(None, description="Account name")
    account_id: constr(regex=r"^\d{12}$") = Field(..., description="AWS account id")
    role_arn: Optional[str] = Field(None, description="ARN of the role")
    external_id: Optional[str] = Field(
        None,
        description="Designated external identifier to provide a safeguard against brute force attempts",
    )
    read_only: Optional[bool] = Field(
        False,
        description="Optional value (defaults to false) to indicate whether Noq has the ability to modify resources on the hub account.",
    )


class Provider(Enum):
    okta = "okta"


class MfaDetails(BaseModel):
    provider: Provider
    url: str
    api_token: str


class MfaSupport(BaseModel):
    enabled: Optional[bool] = Field(
        True, description="Indicate if MFA should be used to submit the request"
    )


class IncludeIgnoreAccountList(BaseModel):
    include: Optional[List[str]] = []
    ignore: Optional[List[str]] = []


class TraApprovalRule(BaseModel):
    name: str
    requires_approval: Optional[bool] = Field(
        True,
        description="Optional value (defaults to true) to indicate whether Temporary Elevated Access requests require approval.",
    )
    enabled: Optional[bool] = Field(
        True,
        description="Optional value (defaults to false) to indicate whether Temporary Elevated Access requests are supported for.",
    )
    mfa: Optional[MfaSupport] = None
    groups: Optional[List[str]] = []
    roles: Optional[List[str]] = []
    accounts: Optional[IncludeIgnoreAccountList] = None


class TraConfig(BaseModel):
    active_users_tag: Optional[str] = Field(
        None,
        description="Customer-specified or default tag used on roles to denote users that currently have temporary role access",
    )
    supported_groups_tag: Optional[str] = Field(
        None,
        description="Customer-specified or default tag used on roles to denote groups that can request temporary role access",
    )
    requires_approval: Optional[bool] = Field(
        True,
        description="Optional value (defaults to true) to indicate whether Temporary Elevated Access requests require approval.",
    )
    enabled: Optional[bool] = Field(
        False,
        description="Optional value (defaults to false) to indicate whether Temporary Elevated Access requests are supported for.",
    )
    mfa: Optional[MfaSupport] = None
    approval_rules: Optional[List[TraApprovalRule]] = []


class IambicRepoDetails(BaseModel):
    repo_name: Optional[str] = Field(
        None,
        description='Name of the repository including the organization or user. e.g. "my_company/iambic_repo"',
    )
    access_token: Optional[str] = Field(
        None, description="The access token used to access the repository."
    )
    remote_name: Optional[str] = Field(
        "origin",
        description='The remote name to use when pushing to the repository. Defaults to "origin".',
    )
    merge_on_approval: Optional[bool] = Field(
        True,
        description="A boolean value indicating whether the PR for the request should be merged when the request is approved. Defaults to true.",
    )
    git_domain: Optional[str] = Field(
        "github.com", description="The domain of the repo."
    )
    git_provider: Optional[str] = Field(
        "github", description='The git provider. Defaults to "github".'
    )


class Secrets(BaseModel):
    mfa: Optional[MfaDetails] = Field(None, is_secret=True)


class SpokeAccount(BaseModel):
    name: str = Field(
        ..., description="Customer-specified or default spoke role name (NoqSpokeRole)"
    )
    account_name: Optional[str] = Field(None, description="Account name")
    account_id: constr(regex=r"^\d{12}$") = Field(..., description="AWS account id")
    role_arn: Optional[str] = Field(None, description="ARN of the spoke role")
    external_id: Optional[str] = Field(
        None,
        description="Designated external identifier to provide a safeguard against brute force attempts",
    )
    hub_account_arn: Optional[str] = Field(
        None, description="Links to the designated hub role ARN"
    )
    org_management_account: Optional[bool] = Field(
        False,
        description="Optional value (defaults to false) to indicate whether this spoke role has access to the org",
    )
    org_access_checked: Optional[bool] = Field(
        False,
        description="Indicates where this spoke role has been checked for org access already.",
    )
    owners: Optional[List[str]] = Field(
        [], description="Optional user or group that owns the account"
    )
    viewers: Optional[List[str]] = Field(
        [],
        description="Optional list of users or groups that can view resources for the account",
    )
    delegate_admin_to_owner: Optional[bool] = Field(
        False,
        description="Optional value (defaults to false) to indicate whether the owner should be delegated admin rights for policy requests\non this account. If this is set, the delegated admin will be able to approve policy requests pertaining to this account.",
    )
    restrict_viewers_of_account_resources: Optional[bool] = Field(
        False,
        description="Optional value (defaults to false) to indicate whether to restrict who can view resources from this account in Noq.\nIf this is set, viewers will be restricted to the list of users or groups provided in the `viewers` field.",
    )
    read_only: Optional[bool] = Field(
        False,
        description="Optional value (defaults to false) to indicate whether Noq has the ability to modify resources on the account.",
    )


class OrgAccount(BaseModel):
    uuid: Optional[UUID] = Field(
        None,
        description="NOQ needs a unique internal identifier to make this work correctly with the frontend",
    )
    org_id: str = Field(
        ...,
        description="A unique identifier designating the identity of the organization",
    )
    account_id: Optional[constr(regex=r"^\d{12}$")] = Field(
        None, description="AWS account id"
    )
    account_name: Optional[str] = Field(None, description="AWS account name")
    owner: Optional[str] = Field(None, description="AWS account owner")
    automatically_onboard_accounts: Optional[bool] = Field(
        False, description="Automatically Onboard accounts from this org."
    )
    automatically_onboard_accounts_options: Optional[List[str]] = Field(
        [],
        description='Options for automatically onboarded accounts. If "read_only" is configured,\nautomatically onboarded accounts will be configured in a read-only state.',
    )
    accounts_excluded_from_automatic_onboard: Optional[List[str]] = Field(
        [], description="Accounts that can not or should not be automatically onboarded"
    )
    sync_account_names: Optional[bool] = Field(
        True, description="Automatically Sync Account Names from this Org"
    )
    role_names: Optional[List[str]] = Field(
        ["OrganizationAccountAccessRole", "AWSControlTowerExecution"],
        description="A list of the role names to attempt to assume on accounts in the org",
    )


class GoogleOIDCSSOIDPProvider(BaseModel):
    client_id: str = Field(
        ..., description="A unique client_id to be used for identification"
    )
    client_secret: str = Field(
        ..., description="The client secret used to authenticate to SSO IDP"
    )
    authorize_scopes: str = Field(
        ...,
        description="OpenID Connect Clients use scope values as defined in 3.3 of OAuth 2.0 [RFC6749] to specify what access privileges are being requested for Access Tokens. The scopes associated with Access Tokens determine what resources will be available when they are used to access OAuth 2.0 protected endpoints. For OpenID Connect, scopes can be used to request that specific sets of information be made available as Claim Values. This document describes only the scope values used by OpenID Connect.",
    )
    provider_name: constr(regex=r"^Google$") = Field(
        ..., description="The identity provider name."
    )
    provider_type: constr(regex=r"^Google$") = Field(
        ..., description="The identity provider type."
    )


class SamlOIDCSSOIDPProvider(BaseModel):
    MetadataURL: str = Field(
        ..., description="The metadata defining the SAML authentication"
    )
    provider_name: constr(regex=r"^SAML$") = Field(
        ..., description="The identity provider name."
    )
    provider_type: constr(regex=r"^SAML$") = Field(
        ..., description="The identity provider type."
    )


class OIDCSSOIDPProvider(BaseModel):
    client_id: str = Field(
        ...,
        description="A unique client id used for authentication with OIDC providers",
    )
    client_secret: str = Field(
        ...,
        description="A unique client id used for authentication with OIDC providers",
    )
    attributes_request_method: str = Field(
        ...,
        description="A unique client id used for authentication with OIDC providers",
    )
    oidc_issuer: str = Field(
        ...,
        description="A unique client id used for authentication with OIDC providers",
    )
    authorize_scopes: str = Field(
        ...,
        description="A unique client id used for authentication with OIDC providers",
    )
    authorize_url: Optional[str] = Field(
        None,
        description="if not available from discovery URL specified by oidc_issuer key",
    )
    token_url: Optional[str] = Field(
        None,
        description="if not available from discovery URL specified by oidc_issuer key",
    )
    attributes_url: Optional[str] = Field(
        None,
        description="if not available from discovery URL specified by oidc_issuer key",
    )
    jwks_uri: Optional[str] = Field(
        None,
        description="if not available from discovery URL specified by oidc_issuer key",
    )
    attributes_url_add_attributes: Optional[str] = Field(
        None, description="a read-only property that is set automatically"
    )
    provider_name: constr(regex=r"^OIDC$") = Field(
        ..., description="The identity provider name."
    )
    provider_type: constr(regex=r"^OIDC$") = Field(
        ..., description="The identity provider type."
    )


class SSOIDPProviders(BaseModel):
    google: Optional[GoogleOIDCSSOIDPProvider] = None
    saml: Optional[SamlOIDCSSOIDPProvider] = None
    oidc: Optional[OIDCSSOIDPProvider] = None


class Attribute(BaseModel):
    Name: Optional[str] = Field(
        None,
        description="attribute name - reference https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-idp.html#CognitoIdentityProvider.Client.admin_create_user",
    )
    Value: Optional[str] = Field(
        None,
        description="attribute value - reference https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-idp.html#CognitoIdentityProvider.Client.admin_create_user",
    )


class DeliveryMedium(Enum):
    SMS = "SMS"
    EMAIL = "EMAIL"


class MFAOption(BaseModel):
    DeliveryMedium: Optional[DeliveryMedium] = Field(
        None, description="can be either SMS or EMAIL"
    )
    AttributeName: Optional[str] = None


class UserStatus(Enum):
    UNCONFIRMED = "UNCONFIRMED"
    CONFIRMED = "CONFIRMED"
    ARCHIVED = "ARCHIVED"
    COMPROMISED = "COMPROMISED"
    UNKNOWN = "UNKNOWN"
    RESET_REQUIRED = "RESET_REQUIRED"
    FORCE_CHANGE_PASSWORD = "FORCE_CHANGE_PASSWORD"
    EXTERNAL_PROVIDER = "EXTERNAL_PROVIDER"


class CognitoUser(BaseModel):
    Username: str = Field(
        ...,
        description="required - The username for the user. Must be unique within the user pool. Must be a UTF-8 string between 1 and 128 characters. After the user is created, the username can't be changed.",
    )
    Attributes: Optional[List[Attribute]] = []
    Enabled: Optional[bool] = None
    MFAOptions: Optional[List[MFAOption]] = Field(
        [], description="Align with what we get back from cognito list users"
    )
    Groups: Optional[List[str]] = Field(
        [],
        description="assigns Cognito group memberships to user account; these groups *must* exist before they can be assigned",
    )
    UserStatus: Optional[UserStatus] = Field(
        None,
        description="Can be UNCONFIRMED, CONFIRMED, ARCHIVED, COMPROMISED, UNKNOWN, RESET_REQUIRED, FORCE_CHANGE_PASSWORD, EXTERNAL_PROVIDER",
    )


class CognitoGroup(BaseModel):
    GroupName: Optional[str] = Field(
        None, description="required - The name of the group. Must be unique."
    )
    Description: Optional[str] = Field(
        "",
        description="uhm... description is the description, and that is this description of the description",
    )
    RoleArn: Optional[str] = Field(
        None, description="The role Amazon Resource Name (ARN) for the group."
    )


class CognitoAccounts(BaseModel):
    users: Optional[List[CognitoUser]] = None
    groups: Optional[List[CognitoGroup]] = None


class ChallengeUrl(BaseModel):
    enabled: Optional[bool] = Field(
        None, description="Whether CLI authentication via Challenge URL is enabled"
    )


class SlackIntegration(BaseModel):
    enabled: Optional[bool] = Field(
        None, description="Whether the slack webhook is enabled"
    )
    webhook_url: Optional[str] = Field(
        None, description="The slack webhook URL to configure for the callback"
    )


class CloudtrailDetection(BaseModel):
    tenant: Optional[str] = Field(None, description="TODO")
    error_code: Optional[str] = Field(None, description="Decoded error code")
    error_message: Optional[str] = Field(None, description="Decoded error message")
    arn: Optional[str] = Field(None, description="principal arn")
    session_name: Optional[str] = Field(None, description="TODO")
    source_ip: Optional[str] = Field(None, description="TODO")
    event_call: Optional[str] = Field(None, description="TODO")
    epoch_event_time: Optional[int] = Field(None, description="TODO")
    ttl: Optional[int] = Field(None, description="TODO")
    count: Optional[int] = Field(None, description="TODO")
    resource: Optional[str] = Field(None, description="TODO")
    request_id: Optional[str] = Field(None, description="TODO")
    generated_policies: Optional[Dict[str, Any]] = Field(None, description="TODO")


class CloudtrailDetectionConfiguration(BaseModel):
    enabled: Optional[bool] = Field(
        False,
        description="Whether cloudtrail is enabled for a specified account id, defaults to false",
    )
    event_ttl: Optional[int] = Field(
        86400, description="Time to live of the event, defaults to 86400"
    )
    max_messages_to_process: Optional[int] = Field(
        100, description="Maximum number of messages that are processes"
    )
    queue_arn: str = Field(
        ...,
        description="The queue ARN to which the cloud trail detection celery task should subscribe to",
    )
    event_bridge_substitutions: Optional[List[str]] = None


class AutomaticPolicyRequest(BaseModel):
    policy: str = Field(
        ..., description="The json dumped policy requested for approval"
    )
    role: str = Field(
        ...,
        description="The AWS Role arn",
        example="arn:aws:iam::111118675309:role/AutomaticPermissionsRole",
    )


class Status3(Enum):
    approved = "approved"
    pending = "pending"
    denied = "denied"
    applied_awaiting_execution = "applied_awaiting_execution"
    applied_and_success = "applied_and_success"
    applied_and_failure = "applied_and_failure"


class ExtendedAutomaticPolicyRequest(BaseModel):
    id: str = Field(..., description="A sha256 hash that represents the policy request")
    role: str = Field(
        ...,
        description="The AWS Role arn",
        example="arn:aws:iam::111118675309:role/AutomaticPermissionsRole",
    )
    account: SpokeAccount
    role_owner: Optional[str] = Field(None, description="The owner of the AWS role")
    user: str = Field(..., description="The AWS user requesting the generated policy")
    event_time: datetime = Field(..., description="The time the request was made")
    error: Optional[str] = Field(
        None, description="The AWS response that caused the automatic policy request"
    )
    system: Optional[str] = Field(
        None, description="The information of the device the request was generated on"
    )
    process: Optional[str] = Field(
        None,
        description="Information about the running process that caused the automatic policy request to be generated",
    )
    policy: Dict[str, Any] = Field(
        ..., description="The json representation of the policy requested for approval"
    )
    last_updated: Optional[datetime] = Field(
        None, description="The last time the policy request was updated."
    )
    status: Optional[Status3] = Field(
        "pending", description="The policy request's status"
    )


class IambicTemplateChange(BaseModel):
    path: str = Field(
        ..., description="The path of the template including the filename"
    )
    body: Optional[str] = Field(None, description="The template's content")


class IambicRequest(BaseModel):
    justification: str = Field(..., description="The reason for the request")
    changes: List[IambicTemplateChange]


class RequestComment(BaseModel):
    id: Optional[str] = None
    body: Optional[str] = None
    created_by: Optional[str] = None
    created_at: Optional[int] = None


class IambicDetailResponse(BaseModel):
    id: Optional[str] = None
    pull_request_id: Optional[int] = None
    repo_name: Optional[str] = None
    justification: Optional[str] = Field(None, description="The reason for the request")
    changes: Optional[List[IambicTemplateChange]] = None
    comments: Optional[List[RequestComment]] = None
    status: Optional[str] = None
    created_by: Optional[str] = None
    created_at: Optional[int] = None
    mergeable: Optional[bool] = None
    is_merged: Optional[bool] = None
    merged_at: Optional[int] = None
    closed_at: Optional[int] = None
    rejected_by: Optional[str] = None
    approved_by: Optional[List[str]] = None
    allowed_approvers: Optional[List[str]] = None


class IambicListResponse(BaseModel):
    id: Optional[str] = None
    pull_request_id: Optional[int] = None
    repo_name: Optional[str] = None
    justification: Optional[str] = Field(None, description="The reason for the request")
    status: Optional[str] = None
    created_by: Optional[str] = None
    created_at: Optional[int] = None
    rejected_by: Optional[str] = None
    approved_by: Optional[List[str]] = None
    allowed_approvers: Optional[List[str]] = None


class UserLoginRequest(BaseModel):
    email: EmailStr
    password: str
    mfa_token: Optional[str] = None


class UserMfaVerificationRequest(BaseModel):
    mfa_token: str


class Command1(Enum):
    request = "request"
    reset = "reset"


class UserForgotPasswordRequest(BaseModel):
    command: Command1
    email: EmailStr = Field(..., description="Email is laways required")
    password: Optional[str] = Field(None, description="Only required if command=reset")
    token: Optional[str] = Field(None, description="Only required if command=reset")


class RequestModel(BaseModel):
    id: Optional[str] = None
    request_url: Optional[str] = None
    principal: Union[
        AwsResourcePrincipalModel,
        HoneybeeAwsResourceTemplatePrincipalModel,
        TerraformAwsResourcePrincipalModel,
    ]
    timestamp: datetime
    justification: Optional[str] = None
    requester_email: str
    approvers: List[str] = Field(
        ...,
        description="list of approvers, derived from approvers of `resource`s in `changes`",
    )
    request_status: RequestStatus
    cross_account: Optional[bool] = Field(
        None, description="if true, the request touches cross-account resources"
    )
    arn_url: Optional[str] = Field(None, description="the principal arn's URL")
    admin_auto_approve: Optional[bool] = False


class ChangeGeneratorModel(BaseModel):
    principal: Optional[
        Union[
            AwsResourcePrincipalModel,
            HoneybeeAwsResourceTemplatePrincipalModel,
            TerraformAwsResourcePrincipalModel,
        ]
    ] = None
    generator_type: GeneratorType
    resource_arn: Optional[Union[str, List[str]]] = Field(
        None,
        description="The ARN(s) of the resource being accessed. This is often SQS/SNS/S3/etc. ARNs. It is possible that the\nresource policies will need to be modified if the change is approved and successful.",
        example=[
            "arn:aws:sqs:us-east-1:123456789012:sqs_queue,",
            "arn:aws:sqs:us-west-2:123456789012:sqs_queue2,",
        ],
    )
    version: Optional[str] = Field(2.0, description="Version")
    user: Optional[str] = Field(
        None, description="Email address of user creating the change"
    )
    action_groups: Optional[List[str]] = Field(None, description="Action groups")
    policy_name: Optional[constr(regex=r"^[a-zA-Z0-9+=,.@\\-_]+$")] = Field(
        None, description="Optional policy name for the change, if applicable."
    )
    effect: Optional[constr(regex=r"^(Allow|Deny)$")] = Field(
        "Allow", description="The effect. By default, this is allow"
    )
    condition: Optional[Dict[str, Any]] = Field(
        None,
        description="Optional condition for the change",
        example='{\n    "StringEquals": {"iam:PassedToService": "ec2.amazonaws.com"},\n    "StringLike": {\n        "iam:AssociatedResourceARN": [\n            "arn:aws:ec2:us-east-1:111122223333:instance/*",\n            "arn:aws:ec2:us-west-1:111122223333:instance/*"\n        ]\n    }\n}',
    )
    service: Optional[str] = None
    bucket_prefix: Optional[str] = None
    policy: Optional[Dict[str, Any]] = Field(
        None,
        description="Optional full policy statement provided by frontend",
        example='{\n  "Version": "2012-10-17",\n  "Statement": [\n      {\n          "Action": [\n              "s3:GetObject",\n          "Effect": "Allow",\n          "Resource": [\n              "arn:aws:s3:::abc",\n              "arn:aws:s3:::abc/*"\n          ],\n      }\n  ]\n}',
    )
    include_accounts: Optional[List[str]] = Field(
        None,
        description="An array of accounts to include this policy on. This is only relevant for templated\nIAM roles. By default, the change will apply to all of the accounts the template is deployed to.",
        example=["account_a", "account_b", "..."],
    )
    exclude_accounts: Optional[List[str]] = Field(
        None,
        description="An array of accounts to explicitly exclude this policy on. This is only relevant for templated\nIAM roles. By default, exclude_accounts is null and the change will apply to all of the accounts",
        example=["account_a", "account_b", "..."],
    )
    extra_actions: Optional[List[str]] = Field(
        None,
        description="An array with a list of extra actions the user wants appended to the policy",
        example=["*", "s3:getobject", "s3:list*"],
    )


class AdvancedChangeGeneratorModel(ChangeGeneratorModel):
    generator_type: constr(regex=r"advanced")
    iam_action: Optional[str] = Field(None, example="kinesis:AddTagsToStream")
    resource: Optional[str] = Field(None, example="*")


class GenericChangeGeneratorModel(ChangeGeneratorModel):
    action_groups: List[str]
    resource_arn: Union[str, List[str]] = Field(
        ...,
        description="The ARN(s) of the resource being accessed. This is often SQS/SNS/S3/etc. ARNs. It is possible that the\nresource policies will need to be modified if the change is approved and successful.",
        example=["arn:aws:sqs:us-east-1:123456789012:sqs_queue"],
    )


class CrudChangeGeneratorModel(ChangeGeneratorModel):
    generator_type: constr(regex=r"crud_lookup")
    action_groups: List[str]
    service_name: str


class S3ChangeGeneratorModel(ChangeGeneratorModel):
    generator_type: constr(regex=r"s3")
    resource_arn: Union[str, List[str]] = Field(
        ...,
        description="The ARN(s) of the S3 resource(s) being accessed.",
        example=["arn:aws:s3:::example_bucket"],
    )
    bucket_prefix: str = Field(..., example="/awesome/prefix/*")
    action_groups: List[str]


class CustomIamChangeGeneratorModel(ChangeGeneratorModel):
    generator_type: constr(regex=r"custom_iam")
    policy: Dict[str, Any]


class SQSChangeGeneratorModel(ChangeGeneratorModel):
    generator_type: constr(regex=r"sqs")
    action_groups: List[str]


class SNSChangeGeneratorModel(ChangeGeneratorModel):
    generator_type: constr(regex=r"sns")
    action_groups: List[str]


class SESChangeGeneratorModel(ChangeGeneratorModel):
    generator_type: constr(regex=r"ses")
    from_address: str
    action_groups: Optional[List[str]] = None


class PolicyCondenserChangeModel(ChangeModel):
    policy_name: Optional[str] = None
    change_type: Optional[constr(regex=r"policy_condenser")] = None
    detach_managed_policies: Optional[bool] = True
    remove_unused_permissions: Optional[bool] = False
    policy: Optional[PolicyModel] = None
    old_policy: Optional[PolicyModel] = None


class InlinePolicyChangeModel(ChangeModel):
    policy_name: Optional[str] = None
    new: Optional[bool] = True
    supported: Optional[bool] = True
    action: Optional[Action] = None
    change_type: Optional[constr(regex=r"inline_policy")] = None
    policy: Optional[PolicyModel] = None
    old_policy: Optional[PolicyModel] = None


class AssumeRolePolicyChangeModel(ChangeModel):
    change_type: Optional[constr(regex=r"assume_role_policy")] = None
    policy: Optional[PolicyModel] = None
    old_policy: Optional[PolicyModel] = None
    source_change_id: Optional[str] = Field(
        None,
        description="the change model ID of the source change, that this change was generated from",
    )


class ResourcePolicyChangeModel(ChangeModel):
    change_type: Optional[constr(regex=r"resource_policy|sts_resource_policy")] = None
    arn: constr(
        regex=r"(^arn:([^:]*):([^:]*):([^:]*):(|\*|[\d]{12}|cloudfront|aws):(.+)$)|^\*$"
    )
    source_change_id: Optional[str] = Field(
        None,
        description="the change model ID of the source change, that this change was generated from",
    )
    supported: Optional[bool] = Field(
        None,
        description="whether we currently support this type of resource policy change or not",
    )
    policy: PolicyModel
    old_policy: Optional[PolicyModel] = None


class ManagedPolicyResourceChangeModel(ChangeModel):
    new: Optional[bool] = True
    change_type: Optional[constr(regex=r"managed_policy_resource")] = None
    policy: Optional[PolicyModel] = None
    old_policy: Optional[PolicyModel] = None


class ChangeModelArray(BaseModel):
    changes: List[
        Union[
            PolicyCondenserChangeModel,
            InlinePolicyChangeModel,
            ManagedPolicyChangeModel,
            PermissionsBoundaryChangeModel,
            ResourcePolicyChangeModel,
            AssumeRolePolicyChangeModel,
            TraRoleChangeModel,
            RoleAccessChangeModel,
            ResourceTagChangeModel,
            GenericFileChangeModel,
            ManagedPolicyResourceChangeModel,
            CreateResourceChangeModel,
            DeleteResourceChangeModel,
        ]
    ]


class CloudAccountModelArray(BaseModel):
    accounts: Optional[List[CloudAccountModel]] = None


class CommentModel(BaseModel):
    id: str
    timestamp: datetime
    edited: Optional[bool] = None
    last_modified: Optional[datetime] = None
    user_email: str
    user: Optional[UserModel] = None
    text: str


class RequestCreationModel(BaseModel):
    changes: ChangeModelArray
    justification: Optional[str] = None
    dry_run: Optional[bool] = False
    admin_auto_approve: Optional[bool] = False
    expiration_date: Optional[datetime] = Field(
        None, description="Date to expire requested policy"
    )
    ttl: Optional[int] = Field(
        None,
        description="The time, in seconds, before the request expires after it has been approved.",
        example=43200,
    )
    credentials: Optional[CloudCredentials] = Field(None, is_secret=True)
    auto_merge: Optional[bool] = Field(
        False, description="attempt to automatically merge two policies"
    )


class ExtendedRequestModel(RequestModel):
    changes: ChangeModelArray
    requester_info: UserModel
    reviewer: Optional[str] = None
    comments: Optional[List[CommentModel]] = None
    expiration_date: Optional[datetime] = Field(
        None, description="Date to expire requested policy or role"
    )
    ttl: Optional[conint(ge=1)] = Field(
        None,
        description="The time, in seconds, before the request expires after it has been approved.",
        example=43200,
    )


class ChangeGeneratorModelArray(BaseModel):
    changes: List[
        Union[
            S3ChangeGeneratorModel,
            SQSChangeGeneratorModel,
            SNSChangeGeneratorModel,
            SESChangeGeneratorModel,
            CrudChangeGeneratorModel,
            GenericChangeGeneratorModel,
            CustomIamChangeGeneratorModel,
        ]
    ]


class RequestCreationResponse(BaseModel):
    errors: Optional[int] = None
    request_created: Optional[bool] = None
    request_id: Optional[str] = None
    request_url: Optional[str] = None
    action_results: Optional[List[ActionResult]] = None
    extended_request: Optional[ExtendedRequestModel] = None
